{\sffamily\normalsize{\color{sciorange} MSD RADIX SORT}}\vspace{1mm}\\
\footnotesize 
MSD radix sort first partitions the strings into different buckets based on
what their first symbol is, then recursively partitions \emph{those} buckets
based on what the second symbol is, and so on.  When only single-element
buckets or buckets containing only strings shorter than the recursion depth
are left, the results are concatenated and output.\\

MSD radix sort never needs to process a symbol twice, technically giving it
$O(L(R) + n)$ complexity assuming a finite alphabet.  However, the complexity
is dominated by the bucket container data structure: if $\sigma$ is the size of the
alphabet and if the buckets are stored in a binary search tree, each addition
takes $O(\log \sigma)$ time.  If they are stored in an array or a hash table, merging
takes $\Theta(\sigma)$ time.\\

Our implementation stores the buckets in an array, using a fixed alphabet size
of 256 but falling back to quicksort when the bucket size is smaller than the
alphabet, which gives it a time complexity of $O(L(R) + n \log \sigma)$.
