 {\sffamily\normalsize{\color{sciorange}CONCLUSION}}\vspace{-7mm}\small\\
 \footnotesize 
\begin{multicols}{3}
Our choice of a fixed alphabet of $256$ symbols for MSD radix sort definitely
hurt its performance: less than half of the buckets allocated at each
partitioning step are ever used to hold any strings with every other dataset
besides WORDS.\\

While fast in theory, Quicksort versions that were not sorting in-place were rather sluggish. Some of the peformance degradation could have been caused by $O(n \log n)$  memory requirement. Coupled with read/write access to non-contiguous memory areas the resulting cache-misses caused performance penalty.\\

It was interesting to note how much better the in-place algorithms performed on
the more demanding datasets.  Despite being geared towards high-level
programming, it appears there are still performance gains to be had in
low-level programming using Python.\\

In particular, Burst sort came out to lead in a league of its own where the large datasets with with high LCP array sums were used, leaving the other implementations behind, including built-in Timsort that comes shipped with Python
\end{multicols}