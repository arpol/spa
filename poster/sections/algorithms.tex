\begin{textblock}{125}(0,97)
\sffamily\normalsize{\color{sciorange}NEW ALGORITHMS FOR INVERSE BWT}\small\\
\rule[3mm]{125mm}{0.1pt}
\end{textblock} 


\begin{textblock}{60}(0,103) 
  \footnotesize 
  The basic inversion algorithm described above has linear time and
  space complexity, but it still dominates the time and space
  requirements during decompression in programs like bzip2.
  \vspace{1mm}

  It is slow because each memory access during the permutation 
  traversal is essentially random causing many cache misses.
  \vspace{1mm}

  It needs a lot of space for the \rank\ array:
  \begin{align*}
    |\rank| &= n\log n \textrm{ bits} = 4n \textrm{ bytes}\\[-1mm]
    |\textrm{text}| &= n\log\sigma \textrm{ bits} = n \textrm{ bytes}
  \end{align*}
  where $n={}$text length and $\sigma={}$alphabet size.
\end{textblock}

\begin{textblock}{60}(0,152)
  {\sffamily\normalsize{\color{sciorange}
      REFERENCE POINT RANKS}}\vspace{1mm}\\
  \footnotesize 
  We reduce space by storing ranks relative to reference points,
  which can be placed in two ways:\\

  \begin{minipage}[t]{25mm}
    \scriptsize\sffamily
    \centering
    Every $k$th position~\cite{ll2005}
    \begin{center}
      \input{LR-B}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{30mm}
    \scriptsize\sffamily
    \centering
    Every $k$th occurrence [new]
    \begin{center}
      \input{LR-I}
    \end{center}
  \end{minipage}
  \vspace{3mm}

  \begin{minipage}{42mm}
%\scriptsize\sffamily
%\centering
    \raggedright
    A new improvement is to use variable length encoding, where
    a frequent symbol uses less bits for symbol and more bits for rank.
  \end{minipage}
  \hfill
  \begin{minipage}{17mm}
    \begin{center}
      \input{variable}
    \end{center}
  \end{minipage}
  \vspace{1mm}

  Finally, we can trade time for space by replacing \rank\ with
  scanning from the nearest reference point~\cite{ll2005}.
\end{textblock}

\begin{textblock}{60}(65,104) 
  {\sffamily\normalsize{\color{sciorange}
      REPETITION SHORTCUTS}}\vspace{1mm}\\
  \footnotesize 
  Repetitions in the text manifest as \emph{pairs of parallel paths}
  (PPP) in the inverse BWT permutation. We use this as follows.
  \vspace{3mm}

  \begin{minipage}[t]{29mm}
    \scriptsize\sffamily
    \centering
    1. On the {\color{first}first pass},\\observe the PPP\\
    (due to repeated ANA)
    \begin{center}
      \input{copy1}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{29mm}
    \scriptsize\sffamily
    \centering
    2. Replace the {\color{second}other path} by shortcut and
    follow it\\on the second pass
    \begin{center}
      \input{copy2}
    \end{center}
  \end{minipage}
  \vspace{3mm}
  
  The shortcuts reduce the number of cache misses.  This is the
  \emph{fastest} known algorithm.
\end{textblock} 

\begin{textblock}{60}(65,173)
  {\sffamily\normalsize{\color{sciorange}
      WAVELET TREES}}\vspace{1mm}\\
  \footnotesize 
  \emph{Wavelet tree} is a text representation that can be both
  compressed and preprocessed for rank que\-ries with little
  additional space.  They are used with compressed text
  indexes~\cite{nm2007} to answer \emph{general rank queries}:
  \[
  \rank_c(j)=\big|\{i \mid i<j \textrm{ and }
  L[i]=c\}\big|.
  \]
  We need wavelet trees for \emph{special rank queries}:
  \[
  \rank(j)=\rank_{L[j]}(j).
  \]
  We use our own wavelet tree implementations optimized for special
  rank queries.
  \vspace{1mm}

  We combine wavelet trees with reference point
  ranks, obtaining the \emph{most space-efficient} algorithm.
\end{textblock}
